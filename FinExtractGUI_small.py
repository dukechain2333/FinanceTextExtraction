# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'FinExtractGUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import argparse
from FinanceText import FinanceText
import re
import jieba
from pyhanlp import HanLP


class Ui_widget(object):
    def setupUi(self, widget):
        widget.setObjectName("widget")
        widget.resize(429, 589)
        self.label = QtWidgets.QLabel(widget)
        self.label.setGeometry(QtCore.QRect(20, 20, 321, 41))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(widget)
        self.label_2.setGeometry(QtCore.QRect(20, 71, 121, 20))
        self.label_2.setObjectName("label_2")
        self.plainTextEdit = QtWidgets.QPlainTextEdit(widget)
        self.plainTextEdit.setGeometry(QtCore.QRect(20, 100, 361, 141))
        self.plainTextEdit.setObjectName("plainTextEdit")
        self.label_3 = QtWidgets.QLabel(widget)
        self.label_3.setGeometry(QtCore.QRect(20, 260, 121, 21))
        self.label_3.setObjectName("label_3")
        self.plainTextEdit_2 = QtWidgets.QPlainTextEdit(widget)
        self.plainTextEdit_2.setGeometry(QtCore.QRect(20, 290, 361, 141))
        self.plainTextEdit_2.setObjectName("plainTextEdit_2")
        self.label_4 = QtWidgets.QLabel(widget)
        self.label_4.setGeometry(QtCore.QRect(20, 440, 151, 31))
        self.label_4.setObjectName("label_4")
        self.lineEdit = QtWidgets.QLineEdit(widget)
        self.lineEdit.setGeometry(QtCore.QRect(170, 440, 211, 31))
        self.lineEdit.setObjectName("lineEdit")
        self.pushButton = QtWidgets.QPushButton(widget)
        self.pushButton.setGeometry(QtCore.QRect(20, 490, 101, 51))
        self.pushButton.setStyleSheet("color: rgb(255, 255, 255);\n"
                                      "font: 10pt \"Adobe Devanagari\";\n"
                                      "background-color: rgb(47, 67, 94);")
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(self.extractText)
        self.pushButton_2 = QtWidgets.QPushButton(widget)
        self.pushButton_2.setGeometry(QtCore.QRect(150, 490, 101, 51))
        self.pushButton_2.setStyleSheet("color: rgb(255, 255, 255);\n"
                                        "background-color: rgb(246, 3, 3);\n"
                                        "font: 10pt \"Adobe Devanagari\";")
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(self.clearText)
        font = QtGui.QFont()
        font.setFamily("Arial")  # 括号里可以设置成自己想要的其它字体
        font.setPointSize(8)
        self.label_5 = QtWidgets.QLabel(widget)
        self.label_5.setGeometry(QtCore.QRect(130, 565, 381, 31))
        self.label_5.setFont(font)
        self.label_5.setObjectName("label_5")

        self.retranslateUi(widget)
        QtCore.QMetaObject.connectSlotsByName(widget)

    def retranslateUi(self, widget):
        _translate = QtCore.QCoreApplication.translate
        widget.setWindowTitle(_translate("widget", "Gorilla 自动摘要"))
        self.label.setText(_translate("widget",
                                      "<html><head/><body><p><span style=\" font-size:20pt; font-weight:600;\">金融文本摘要生成系统</span></p></body></html>"))
        self.label_2.setText(_translate("widget",
                                        "<html><head/><body><p><span style=\" font-size:14pt; font-weight:600;\">原文本输入框</span></p></body></html>"))
        self.label_3.setText(_translate("widget",
                                        "<html><head/><body><p><span style=\" font-size:14pt; font-weight:600;\">自动摘要结果</span></p></body></html>"))
        self.label_4.setText(_translate("widget",
                                        "<html><head/><body><p><span style=\" font-size:14pt; font-weight:600;\">请输入您的偏好</span></p></body></html>"))
        self.pushButton.setText(_translate("widget", "提取摘要"))
        self.pushButton_2.setText(_translate("widget", "清空文本"))
        self.label_5.setText(_translate("widget", "第六届“汇创青春”上海大学生文化创意作品展示活动参赛作品"))

    def inputTextWrite(self):
        text = self.plainTextEdit.toPlainText()
        with open('testText.txt', encoding='utf8', mode='w') as file:
            file.write(text)

    def outputTextRead(self):
        with open('FinExtract.txt', encoding='utf8', mode='r') as file:
            text = file.readlines()
        self.plainTextEdit_2.clear()
        for line in text:
            self.plainTextEdit_2.appendPlainText(line)

    def extractText(self):
        self.inputTextWrite()
        financeText = FinanceText('testText.txt', 'FinExtract.txt', self.lineEdit.text())
        financeText.train_model()

        topic_words = []
        sentence_words = []
        topic_sentence = []
        dic = {}
        res = []
        finalSentence = ''

        for line in financeText.text:
            line = re.sub(" ", "", line)
            line = re.sub("[].\\/_,$%^*(+\"\')]+|[+——（）【】、~@#￥%……&*（）“”《》]+", "", line)
            # topic_sentence.append(line)
            topic_words = jieba.lcut(line)
            # 建立词典统计切分的各个词的频率
            for word in topic_words:
                if word not in dic:
                    dic[word] = 1
                else:
                    dic[word] += 1
            pattern = r'\.|/|;|\'|`|\[|\]|<|>|\?|:|"|\{|\}|\~|!|@|#|\$|%|\^|&|\(|\)|-|=|\_|\+|。|；|‘|’|【|】|·|！| |…|（|）'
            result_list = re.split(pattern, line)

            topic_sentence.extend(result_list)

            for i in range(len(topic_sentence)):
                score = 0
                for word in jieba.lcut(topic_sentence[i]):
                    score += dic.get(word, 0)
                res.append(score)
            score_dic = {}
            for i in range(len(topic_sentence) - 1):
                temp_similarity = financeText.lda_sim(topic_words[i])
                score_dic[i] = (res[i] / (len(jieba.lcut(topic_sentence[i])) + 1)) * abs(temp_similarity)
            result = sorted(score_dic.items(), key=lambda kv: (kv[1], kv[0]), reverse=True)
            result1 = result[:2]
            for key in result1:
                # 输出原句
                print(topic_sentence[key[0]])
                # 用HanLP进行分隔
                ans = HanLP.parseDependency(topic_sentence[key[0]].strip())
                # print(ans.toString())
                # 对分隔数据进行处理
                textStructure, graph = financeText.hanlp_split(ans.toString())
                # print(graph)
                # 生成词语关系图
                graphic = financeText.showGraph(graph)
                # 对关系图剪枝
                graphCut = financeText.removeGraphNode(graphic)
                # print(graphCut.nodes)
                # 拼凑新的句子
                sentence = financeText.completeSentence(textStructure, graphCut)
                finalSentence += sentence + '。'
                print(sentence)

            topic_words = []
            sentence_words = []
            topic_sentence = []
            dic = {}
            res = []

        financeText.textWrite(finalSentence)
        self.outputTextRead()

    def clearText(self):
        self.plainTextEdit.clear()
        self.plainTextEdit_2.clear()
        self.lineEdit.clear()
